using Godot;
using System;
using System.Collections.Generic;
using System.Linq;

namespace ApexSim;

public partial class TrackCard : PanelContainer
{
    [Signal]
    public delegate void CardClickedEventHandler(TrackCard card);

    // Static index of track IDs to file paths, built once on first use
    private static Dictionary<string, string> _trackIndexCache = new();
    private static bool _indexBuilt = false;

    private Label? _nameLabel;
    private Label? _lengthLabel;
    private Node3D? _trackModelParent;
    private ColorRect? _selectionIndicator;
    private ColorRect? _selectionBorder;
    private ColorRect? _hoverEffect;
    private SubViewport? _viewport;
    private Camera3D? _camera;

    private TrackConfigSummary? _trackConfig;
    private Node3D? _centerlineVisualization;
    private bool _isSelected = false;
    private bool _isHovered = false;

    public TrackConfigSummary? TrackConfig => _trackConfig;
    public bool IsSelected
    {
        get => _isSelected;
        set
        {
            _isSelected = value;
            UpdateSelectionVisuals();
        }
    }

    public override void _Ready()
    {
        _nameLabel = GetNode<Label>("VBox/InfoSection/TrackName");
        _lengthLabel = GetNode<Label>("VBox/InfoSection/TrackInfo/Length");
        _trackModelParent = GetNode<Node3D>("VBox/ModelViewport/SubViewport/TrackModel");
        _selectionIndicator = GetNode<ColorRect>("SelectionIndicator");
        _selectionBorder = GetNode<ColorRect>("SelectionBorder");
        _hoverEffect = GetNode<ColorRect>("HoverEffect");
        _viewport = GetNode<SubViewport>("VBox/ModelViewport/SubViewport");
        _camera = GetNode<Camera3D>("VBox/ModelViewport/SubViewport/Camera3D");

        // Set up mouse interaction
        MouseEntered += OnMouseEntered;
        MouseExited += OnMouseExited;

        // Make the panel clickable
        GuiInput += OnGuiInput;

        // Enable viewport rendering when card becomes visible
        if (_viewport != null)
        {
            _viewport.RenderTargetUpdateMode = SubViewport.UpdateMode.Always;
        }

        // Build track index on first card creation
        if (!_indexBuilt)
        {
            BuildTrackIndex();
        }
    }

    public void SetupCard(TrackConfigSummary trackConfig)
    {
        _trackConfig = trackConfig;

        if (_nameLabel != null)
            _nameLabel.Text = trackConfig.Name;

        if (_lengthLabel != null)
            _lengthLabel.Text = $"Track ID: {trackConfig.Id.Substring(0, 8)}...";

        // Create a visual representation of the track centerline from the track files
        CreateCenterlineVisualizationFromFile();
    }

    private void CreateCenterlineVisualizationFromFile()
    {
        if (_trackModelParent == null || _trackConfig == null) return;

        // Clear any existing visualization
        if (_centerlineVisualization != null)
        {
            _centerlineVisualization.QueueFree();
            _centerlineVisualization = null;
        }

        _centerlineVisualization = new Node3D();
        _trackModelParent.AddChild(_centerlineVisualization);

        try
        {
            // Try to find and load the track file by ID
            var trackFile = FindTrackFileById(_trackConfig.Id);
            if (trackFile != null)
            {
                var centerlinePoints = ParseTrackCenterline(trackFile);
                if (centerlinePoints.Count > 0)
                {
                    DrawCenterlineFromPoints(centerlinePoints);
                    return;
                }
            }
        }
        catch (Exception ex)
        {
            GD.PrintErr($"[TrackCard] Error loading centerline for {_trackConfig.Name}: {ex.Message}");
        }

        // Fallback to simple visualization if file not found
        CreateSimpleTrackRepresentation();
    }

    private string? FindTrackFileById(string trackId)
    {
        // Use the cached index
        if (_trackIndexCache.TryGetValue(trackId, out var filePath))
        {
            GD.Print($"[TrackCard] Found track file from index: {filePath}");
            return filePath;
        }

        GD.PrintErr($"[TrackCard] Track ID not in index: {trackId}");
        return null;
    }

    private static void BuildTrackIndex()
    {
        if (_indexBuilt) return;
        
        GD.Print("[TrackCard] Building track index...");
        _trackIndexCache.Clear();

        var trackDirs = new[] { "/home/guido/apexsim/content/tracks/real", "/home/guido/apexsim/content/tracks/simple" };
        
        foreach (var dir in trackDirs)
        {
            if (!DirAccess.DirExistsAbsolute(dir))
            {
                GD.PrintErr($"[TrackCard] Directory does not exist: {dir}");
                continue;
            }
            
            var dirAccess = DirAccess.Open(dir);
            if (dirAccess == null)
            {
                GD.PrintErr($"[TrackCard] Failed to open directory: {dir}");
                continue;
            }

            var files = dirAccess.GetFiles();
            GD.Print($"[TrackCard] Scanning {files.Length} files in {dir}");
            
            foreach (var fileName in files)
            {
                if (fileName.EndsWith(".yaml") || fileName.EndsWith(".yml") || fileName.EndsWith(".json"))
                {
                    var filePath = $"{dir}/{fileName}";
                    
                    try
                    {
                        var file = FileAccess.Open(filePath, FileAccess.ModeFlags.Read);
                        if (file != null)
                        {
                            var firstLine = file.GetLine().Trim();
                            
                            // First line should be track_id
                            if (firstLine.Contains("track_id:"))
                            {
                                var idValue = ExtractIdValue(firstLine);
                                if (!string.IsNullOrEmpty(idValue))
                                {
                                    // Convert to res:// path for consistency
                                    var resPath = $"res://{filePath.Replace("/home/guido/apexsim/", "")}";
                                    _trackIndexCache[idValue] = resPath;
                                    GD.Print($"[TrackCard]   Indexed: {idValue} -> {fileName}");
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        GD.PrintErr($"[TrackCard] Exception indexing {filePath}: {ex.Message}");
                    }
                }
            }
        }
        
        _indexBuilt = true;
        GD.Print($"[TrackCard] Index built with {_trackIndexCache.Count} tracks");
    }

    private static string ExtractIdValue(string line)
    {
        try
        {
            // Handle format: track_id: uuid-string
            var idx = line.IndexOf("track_id:");
            if (idx >= 0)
            {
                var valuePart = line.Substring(idx + 9).Trim();
                return valuePart;
            }
        }
        catch { }
        return "";
    }

    private List<Vector3> ParseTrackCenterline(string filePath)
    {
        var centerlinePoints = new List<Vector3>();

        try
        {
            var file = FileAccess.Open(filePath, FileAccess.ModeFlags.Read);
            if (file == null) return centerlinePoints;

            var content = file.GetAsText();
            
            // Simple YAML parsing for nodes
            var lines = content.Split('\n');
            bool inNodes = false;
            Vector3? currentPoint = null;

            foreach (var line in lines)
            {
                var trimmed = line.Trim();

                if (trimmed == "nodes:" || trimmed == "nodes: []")
                {
                    inNodes = true;
                    continue;
                }

                if (inNodes && trimmed.StartsWith("- x:"))
                {
                    // Start of new node
                    currentPoint = Vector3.Zero;
                }

                if (currentPoint.HasValue)
                {
                    if (trimmed.StartsWith("x:"))
                    {
                        var value = ExtractFloatValue(trimmed);
                        if (value.HasValue)
                            currentPoint = new Vector3(value.Value, currentPoint.Value.Y, currentPoint.Value.Z);
                    }
                    else if (trimmed.StartsWith("y:"))
                    {
                        var value = ExtractFloatValue(trimmed);
                        if (value.HasValue)
                            currentPoint = new Vector3(currentPoint.Value.X, value.Value, currentPoint.Value.Z);
                    }
                    else if (trimmed.StartsWith("z:"))
                    {
                        var value = ExtractFloatValue(trimmed);
                        if (value.HasValue)
                            currentPoint = new Vector3(currentPoint.Value.X, currentPoint.Value.Y, value.Value);
                    }

                    // Check if we're moving to next node or section
                    if (!trimmed.StartsWith("-") && !trimmed.StartsWith("x:") && !trimmed.StartsWith("y:") && !trimmed.StartsWith("z:") && trimmed != "" && !char.IsWhiteSpace(line[0]))
                    {
                        if (currentPoint.HasValue)
                        {
                            centerlinePoints.Add(currentPoint.Value);
                            currentPoint = null;
                        }
                        inNodes = false;
                    }
                }
            }

            // Add last point
            if (currentPoint.HasValue)
                centerlinePoints.Add(currentPoint.Value);

            GD.Print($"[TrackCard] Parsed {centerlinePoints.Count} centerline points from {filePath}");
        }
        catch (Exception ex)
        {
            GD.PrintErr($"[TrackCard] Error parsing track file: {ex.Message}");
        }

        return centerlinePoints;
    }

    private float? ExtractFloatValue(string line)
    {
        try
        {
            var parts = line.Split(':');
            if (parts.Length >= 2)
            {
                var valueStr = parts[1].Trim();
                if (float.TryParse(valueStr, out var value))
                    return value;
            }
        }
        catch { }
        return null;
    }

    private void DrawCenterlineFromPoints(List<Vector3> points)
    {
        if (_centerlineVisualization == null || points.Count < 2) return;

        // Calculate bounds to fit in view
        var minX = points.Min(p => p.X);
        var maxX = points.Max(p => p.X);
        var minY = points.Min(p => p.Y);
        var maxY = points.Max(p => p.Y);

        var rangeX = maxX - minX;
        var rangeY = maxY - minY;
        var padding = 0.1f;
        var range = Mathf.Max(rangeX, rangeY) * (1 + padding * 2);
        var center = new Vector3((minX + maxX) / 2, (minY + maxY) / 2, 0);

        // Create line mesh
        var meshInstance = new MeshInstance3D();
        var mesh = new ArrayMesh();

        // Draw centerline as a line strip
        var vertexList = new List<Vector3>();
        var indexList = new List<int>();

        for (int i = 0; i < points.Count; i++)
        {
            var p = points[i];
            var normalized = new Vector3(
                ((p.X - center.X) / range) * 1.5f,
                ((p.Y - center.Y) / range) * 1.5f,
                -0.1f
            );
            vertexList.Add(normalized);
            if (i > 0)
            {
                indexList.Add(i - 1);
                indexList.Add(i);
            }
        }

        var arrays = new Godot.Collections.Array();
        arrays.Resize((int)Mesh.ArrayType.Max);
        arrays[(int)Mesh.ArrayType.Vertex] = vertexList.ToArray();
        arrays[(int)Mesh.ArrayType.Index] = indexList.ToArray();

        mesh.AddSurfaceFromArrays(Mesh.PrimitiveType.LineStrip, arrays);
        meshInstance.Mesh = mesh;

        var material = new StandardMaterial3D();
        material.AlbedoColor = new Color(0.2f, 0.8f, 0.3f, 1.0f); // Green
        material.Metallic = 0.1f;
        material.Roughness = 0.6f;
        meshInstance.SetSurfaceOverrideMaterial(0, material);

        _centerlineVisualization.AddChild(meshInstance);

        GD.Print($"[TrackCard] Drew centerline with {points.Count} points for {_trackConfig?.Name}");
    }

    private void CreateSimpleTrackRepresentation()
    {
        if (_centerlineVisualization == null) return;

        // Create a simple torus as fallback
        var meshInstance = new MeshInstance3D();
        var torus = new TorusMesh();
        torus.InnerRadius = 0.8f;
        torus.OuterRadius = 1.0f;
        
        meshInstance.Mesh = torus;

        var material = new StandardMaterial3D();
        material.AlbedoColor = new Color(0.2f, 0.8f, 0.3f, 1.0f); // Green track
        material.Metallic = 0.1f;
        material.Roughness = 0.6f;
        meshInstance.SetSurfaceOverrideMaterial(0, material);

        _centerlineVisualization.AddChild(meshInstance);
        GD.Print($"[TrackCard] Using fallback torus for {_trackConfig?.Name}");
    }

    private void UpdateSelectionVisuals()
    {
        if (_selectionIndicator != null)
            _selectionIndicator.Visible = _isSelected;
        if (_selectionBorder != null)
            _selectionBorder.Visible = _isSelected;
    }

    private void OnMouseEntered()
    {
        _isHovered = true;
        if (_hoverEffect != null)
            _hoverEffect.Visible = !_isSelected;
    }

    private void OnMouseExited()
    {
        _isHovered = false;
        if (_hoverEffect != null)
            _hoverEffect.Visible = false;
    }

    private void OnGuiInput(InputEvent inputEvent)
    {
        if (inputEvent is InputEventMouseButton mouseEvent && mouseEvent.Pressed && mouseEvent.ButtonIndex == MouseButton.Left)
        {
            EmitSignal(SignalName.CardClicked, this);
        }
    }

    public override void _ExitTree()
    {
        if (_centerlineVisualization != null && IsInstanceValid(_centerlineVisualization))
        {
            _centerlineVisualization.QueueFree();
        }
    }
}
